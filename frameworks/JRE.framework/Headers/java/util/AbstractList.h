//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/AbstractList.java
//

#include <JRE/J2ObjC_header.h>

#pragma push_macro("INCLUDE_ALL_JavaUtilAbstractList")
#ifdef RESTRICT_JavaUtilAbstractList
#define INCLUDE_ALL_JavaUtilAbstractList 0
#else
#define INCLUDE_ALL_JavaUtilAbstractList 1
#endif
#undef RESTRICT_JavaUtilAbstractList

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilAbstractList_) && (INCLUDE_ALL_JavaUtilAbstractList || defined(INCLUDE_JavaUtilAbstractList))
#define JavaUtilAbstractList_

#define RESTRICT_JavaUtilAbstractCollection 1
#define INCLUDE_JavaUtilAbstractCollection 1
#include <JRE/java/util/AbstractCollection.h>

#define RESTRICT_JavaUtilList 1
#define INCLUDE_JavaUtilList 1
#include <JRE/java/util/List.h>

@protocol JavaUtilCollection;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionUnaryOperator;
@protocol JavaUtilIterator;
@protocol JavaUtilListIterator;
@protocol JavaUtilSpliterator;

/*!
 @brief This class provides a skeletal implementation of the <code>List</code>
  interface to minimize the effort required to implement this interface
  backed by a "random access" data store (such as an array).For sequential
  access data (such as a linked list), <code>AbstractSequentialList</code> should
  be used in preference to this class.
 <p>To implement an unmodifiable list, the programmer needs only to extend
  this class and provide implementations for the <code>get(int)</code> and 
 <code>size()</code> methods. 
 <p>To implement a modifiable list, the programmer must additionally
  override the <code>set(int, E)</code> method (which otherwise
  throws an <code>UnsupportedOperationException</code>).  If the list is
  variable-size the programmer must additionally override the 
 <code>add(int, E)</code> and <code>remove(int)</code> methods. 
 <p>The programmer should generally provide a void (no argument) and collection
  constructor, as per the recommendation in the <code>Collection</code> interface
  specification. 
 <p>Unlike the other abstract collection implementations, the programmer does 
 <i>not</i> have to provide an iterator implementation; the iterator and
  list iterator are implemented by this class, on top of the "random access"
  methods: 
 <code>get(int)</code>,
  <code>set(int, E)</code>,
  <code>add(int, E)</code> and 
 <code>remove(int)</code>.
  
 <p>The documentation for each non-abstract method in this class describes its
  implementation in detail.  Each of these methods may be overridden if the
  collection being implemented admits a more efficient implementation. 
 <p>This class is a member of the 
 <a href="{@@docRoot}/../technotes/guides/collections/index.html">
  Java Collections Framework</a>.
 @author Josh Bloch
 @author Neal Gafter
 @since 1.2
 */
@interface JavaUtilAbstractList : JavaUtilAbstractCollection < JavaUtilList > {
 @public
  /*!
   @brief The number of times this list has been <i>structurally modified</i>.
   Structural modifications are those that change the size of the
  list, or otherwise perturb it in such a fashion that iterations in
  progress may yield incorrect results. 
 <p>This field is used by the iterator and list iterator implementation
  returned by the <code>iterator</code> and <code>listIterator</code> methods.
  If the value of this field changes unexpectedly, the iterator (or list
  iterator) will throw a <code>ConcurrentModificationException</code> in
  response to the <code>next</code>, <code>remove</code>, <code>previous</code>,
  <code>set</code> or <code>add</code> operations.  This provides 
 <i>fail-fast</i> behavior, rather than non-deterministic behavior in
  the face of concurrent modification during iteration. 
 <p><b>Use of this field by subclasses is optional.</b> If a subclass
  wishes to provide fail-fast iterators (and list iterators), then it
  merely has to increment this field in its <code>add(int, E)</code> and 
 <code>remove(int)</code> methods (and any other methods that it overrides
  that result in structural modifications to the list).  A single call to 
 <code>add(int, E)</code> or <code>remove(int)</code> must add no more than
  one to this field, or the iterators (and list iterators) will throw
  bogus <code>ConcurrentModificationExceptions</code>.  If an implementation
  does not wish to provide fail-fast iterators, this field may be
  ignored.
   */
  jint modCount_;
}

#pragma mark Public

/*!
 @brief Appends the specified element to the end of this list (optional
  operation).
 <p>Lists that support this operation may place limitations on what
  elements may be added to this list.  In particular, some
  lists will refuse to add null elements, and others will impose
  restrictions on the type of elements that may be added.  List
  classes should clearly specify in their documentation any restrictions
  on what elements may be added.
 @param e element to be appended to this list
 @return <code>true</code> (as specified by <code>Collection.add</code>)
 @throw UnsupportedOperationExceptionif the <code>add</code> operation
          is not supported by this list
 @throw ClassCastExceptionif the class of the specified element
          prevents it from being added to this list
 @throw NullPointerExceptionif the specified element is null and this
          list does not permit null elements
 @throw IllegalArgumentExceptionif some property of this element
          prevents it from being added to this list
 */
- (jboolean)addWithId:(id)e;

/*!
 @throw UnsupportedOperationException
 @throw ClassCastException
 @throw NullPointerException
 @throw IllegalArgumentException
 @throw IndexOutOfBoundsException
 */
- (void)addWithInt:(jint)index
            withId:(id)element;

/*!
 @throw UnsupportedOperationException
 @throw ClassCastException
 @throw NullPointerException
 @throw IllegalArgumentException
 @throw IndexOutOfBoundsException
 */
- (jboolean)addAllWithInt:(jint)index
   withJavaUtilCollection:(id<JavaUtilCollection>)c;

/*!
 @brief Removes all of the elements from this list (optional operation).
 The list will be empty after this call returns.
 @throw UnsupportedOperationExceptionif the <code>clear</code> operation
          is not supported by this list
 */
- (void)clear;

/*!
 @brief Compares the specified object with this list for equality.Returns
  <code>true</code> if and only if the specified object is also a list, both
  lists have the same size, and all corresponding pairs of elements in
  the two lists are <i>equal</i>.
 (Two elements <code>e1</code> and 
 <code>e2</code> are <i>equal</i> if <code>(e1==null ? e2==null :
  e1.equals(e2))</code>
 .)  In other words, two lists are defined to be
  equal if they contain the same elements in the same order.
 @param o the object to be compared for equality with this list
 @return <code>true</code> if the specified object is equal to this list
 */
- (jboolean)isEqual:(id)o;

/*!
 @throw IndexOutOfBoundsException
 */
- (id)getWithInt:(jint)index;

/*!
 @brief Returns the hash code value for this list.
 @return the hash code value for this list
 */
- (NSUInteger)hash;

/*!
 @throw ClassCastException
 @throw NullPointerException
 */
- (jint)indexOfWithId:(id)o;

/*!
 @brief Returns an iterator over the elements in this list in proper sequence.
 @return an iterator over the elements in this list in proper sequence
 */
- (id<JavaUtilIterator> __nonnull)iterator;

/*!
 @throw ClassCastException
 @throw NullPointerException
 */
- (jint)lastIndexOfWithId:(id)o;

/*!
 - seealso: #listIterator(int)
 */
- (id<JavaUtilListIterator> __nonnull)listIterator;

/*!
 @throw IndexOutOfBoundsException
 */
- (id<JavaUtilListIterator> __nonnull)listIteratorWithInt:(jint)index;

/*!
 @throw UnsupportedOperationException
 @throw IndexOutOfBoundsException
 */
- (id)removeWithInt:(jint)index;

/*!
 @throw UnsupportedOperationException
 @throw ClassCastException
 @throw NullPointerException
 @throw IllegalArgumentException
 @throw IndexOutOfBoundsException
 */
- (id)setWithInt:(jint)index
          withId:(id)element;

/*!
 @throw IndexOutOfBoundsExceptionif an endpoint index value is out of range
          <code>(fromIndex < 0 || toIndex > size)</code>
 @throw IllegalArgumentExceptionif the endpoint indices are out of order
          <code>(fromIndex > toIndex)</code>
 */
- (id<JavaUtilList> __nonnull)subListWithInt:(jint)fromIndex
                                     withInt:(jint)toIndex;

#pragma mark Protected

/*!
 @brief Sole constructor.
 (For invocation by subclass constructors, typically
  implicit.)
 */
- (instancetype __nonnull)init;

/*!
 @brief Removes from this list all of the elements whose index is between 
 <code>fromIndex</code>, inclusive, and <code>toIndex</code>, exclusive.
 Shifts any succeeding elements to the left (reduces their index).
  This call shortens the list by <code>(toIndex - fromIndex)</code> elements.
  (If <code>toIndex==fromIndex</code>, this operation has no effect.) 
 <p>This method is called by the <code>clear</code> operation on this list
  and its subLists.  Overriding this method to take advantage of
  the internals of the list implementation can <i>substantially</i>
  improve the performance of the <code>clear</code> operation on this list
  and its subLists.
 @param fromIndex index of first element to be removed
 @param toIndex index after last element to be removed
 */
- (void)removeRangeWithInt:(jint)fromIndex
                   withInt:(jint)toIndex;

#pragma mark Package-Private

+ (void)subListRangeCheckWithInt:(jint)fromIndex
                         withInt:(jint)toIndex
                         withInt:(jint)size;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilAbstractList)

FOUNDATION_EXPORT void JavaUtilAbstractList_init(JavaUtilAbstractList *self);

FOUNDATION_EXPORT void JavaUtilAbstractList_subListRangeCheckWithInt_withInt_withInt_(jint fromIndex, jint toIndex, jint size);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilAbstractList)

#endif

#if !defined (JavaUtilAbstractList_RandomAccessSpliterator_) && (INCLUDE_ALL_JavaUtilAbstractList || defined(INCLUDE_JavaUtilAbstractList_RandomAccessSpliterator))
#define JavaUtilAbstractList_RandomAccessSpliterator_

#define RESTRICT_JavaUtilSpliterator 1
#define INCLUDE_JavaUtilSpliterator 1
#include <JRE/java/util/Spliterator.h>

@class JavaUtilAbstractList;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilList;

/*!
 @brief An index-based split-by-two, lazily initialized Spliterator covering
  a List that access elements via <code>List.get</code>.
 If access results in an IndexOutOfBoundsException then a
  ConcurrentModificationException is thrown instead (since the list has
  been structurally modified while traversing).
  If the List is an instance of AbstractList then concurrent modification
  checking is performed using the AbstractList's modCount field.
 */
@interface JavaUtilAbstractList_RandomAccessSpliterator : NSObject < JavaUtilSpliterator >

#pragma mark Public

- (jint)characteristics;

- (jlong)estimateSize;

- (void)forEachRemainingWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (jboolean)tryAdvanceWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (id<JavaUtilSpliterator>)trySplit;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilList:(id<JavaUtilList>)list;

+ (void)checkAbstractListModCountWithJavaUtilAbstractList:(JavaUtilAbstractList *)alist
                                                  withInt:(jint)expectedModCount;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilAbstractList_RandomAccessSpliterator)

FOUNDATION_EXPORT void JavaUtilAbstractList_RandomAccessSpliterator_initWithJavaUtilList_(JavaUtilAbstractList_RandomAccessSpliterator *self, id<JavaUtilList> list);

FOUNDATION_EXPORT JavaUtilAbstractList_RandomAccessSpliterator *new_JavaUtilAbstractList_RandomAccessSpliterator_initWithJavaUtilList_(id<JavaUtilList> list) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilAbstractList_RandomAccessSpliterator *create_JavaUtilAbstractList_RandomAccessSpliterator_initWithJavaUtilList_(id<JavaUtilList> list);

FOUNDATION_EXPORT void JavaUtilAbstractList_RandomAccessSpliterator_checkAbstractListModCountWithJavaUtilAbstractList_withInt_(JavaUtilAbstractList *alist, jint expectedModCount);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilAbstractList_RandomAccessSpliterator)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilAbstractList")
