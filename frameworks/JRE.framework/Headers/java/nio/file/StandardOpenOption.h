//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/nio/file/StandardOpenOption.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaNioFileStandardOpenOption")
#ifdef RESTRICT_JavaNioFileStandardOpenOption
#define INCLUDE_ALL_JavaNioFileStandardOpenOption 0
#else
#define INCLUDE_ALL_JavaNioFileStandardOpenOption 1
#endif
#undef RESTRICT_JavaNioFileStandardOpenOption

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaNioFileStandardOpenOption_) && (INCLUDE_ALL_JavaNioFileStandardOpenOption || defined(INCLUDE_JavaNioFileStandardOpenOption))
#define JavaNioFileStandardOpenOption_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

#define RESTRICT_JavaNioFileOpenOption 1
#define INCLUDE_JavaNioFileOpenOption 1
#include "java/nio/file/OpenOption.h"

@class IOSObjectArray;

typedef NS_ENUM(NSUInteger, JavaNioFileStandardOpenOption_Enum) {
  JavaNioFileStandardOpenOption_Enum_READ = 0,
  JavaNioFileStandardOpenOption_Enum_WRITE = 1,
  JavaNioFileStandardOpenOption_Enum_APPEND = 2,
  JavaNioFileStandardOpenOption_Enum_TRUNCATE_EXISTING = 3,
  JavaNioFileStandardOpenOption_Enum_CREATE = 4,
  JavaNioFileStandardOpenOption_Enum_CREATE_NEW = 5,
  JavaNioFileStandardOpenOption_Enum_DELETE_ON_CLOSE = 6,
  JavaNioFileStandardOpenOption_Enum_SPARSE = 7,
  JavaNioFileStandardOpenOption_Enum_SYNC = 8,
  JavaNioFileStandardOpenOption_Enum_DSYNC = 9,
};

/*!
 @brief Defines the standard open options.
 @since 1.7
 */
@interface JavaNioFileStandardOpenOption : JavaLangEnum < JavaNioFileOpenOption >

@property (readonly, class, nonnull) JavaNioFileStandardOpenOption *READ NS_SWIFT_NAME(READ);
@property (readonly, class, nonnull) JavaNioFileStandardOpenOption *WRITE NS_SWIFT_NAME(WRITE);
@property (readonly, class, nonnull) JavaNioFileStandardOpenOption *APPEND NS_SWIFT_NAME(APPEND);
@property (readonly, class, nonnull) JavaNioFileStandardOpenOption *TRUNCATE_EXISTING NS_SWIFT_NAME(TRUNCATE_EXISTING);
@property (readonly, class, nonnull) JavaNioFileStandardOpenOption *CREATE NS_SWIFT_NAME(CREATE);
@property (readonly, class, nonnull) JavaNioFileStandardOpenOption *CREATE_NEW NS_SWIFT_NAME(CREATE_NEW);
@property (readonly, class, nonnull) JavaNioFileStandardOpenOption *DELETE_ON_CLOSE NS_SWIFT_NAME(DELETE_ON_CLOSE);
@property (readonly, class, nonnull) JavaNioFileStandardOpenOption *SPARSE NS_SWIFT_NAME(SPARSE);
@property (readonly, class, nonnull) JavaNioFileStandardOpenOption *SYNC NS_SWIFT_NAME(SYNC);
@property (readonly, class, nonnull) JavaNioFileStandardOpenOption *DSYNC NS_SWIFT_NAME(DSYNC);
#pragma mark Public

+ (JavaNioFileStandardOpenOption *)valueOfWithNSString:(NSString *)name;

+ (IOSObjectArray *)values;

#pragma mark Package-Private

- (JavaNioFileStandardOpenOption_Enum)toNSEnum;

@end

J2OBJC_STATIC_INIT(JavaNioFileStandardOpenOption)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT JavaNioFileStandardOpenOption *JavaNioFileStandardOpenOption_values_[];

/*!
 @brief Open for read access.
 */
inline JavaNioFileStandardOpenOption *JavaNioFileStandardOpenOption_get_READ(void);
J2OBJC_ENUM_CONSTANT(JavaNioFileStandardOpenOption, READ)

/*!
 @brief Open for write access.
 */
inline JavaNioFileStandardOpenOption *JavaNioFileStandardOpenOption_get_WRITE(void);
J2OBJC_ENUM_CONSTANT(JavaNioFileStandardOpenOption, WRITE)

/*!
 @brief If the file is opened for <code>WRITE</code> access then bytes will be written
  to the end of the file rather than the beginning.
 <p> If the file is opened for write access by other programs, then it
  is file system specific if writing to the end of the file is atomic.
 */
inline JavaNioFileStandardOpenOption *JavaNioFileStandardOpenOption_get_APPEND(void);
J2OBJC_ENUM_CONSTANT(JavaNioFileStandardOpenOption, APPEND)

/*!
 @brief If the file already exists and it is opened for <code>WRITE</code>
  access, then its length is truncated to 0.This option is ignored
  if the file is opened only for <code>READ</code> access.
 */
inline JavaNioFileStandardOpenOption *JavaNioFileStandardOpenOption_get_TRUNCATE_EXISTING(void);
J2OBJC_ENUM_CONSTANT(JavaNioFileStandardOpenOption, TRUNCATE_EXISTING)

/*!
 @brief Create a new file if it does not exist.
 This option is ignored if the <code>CREATE_NEW</code> option is also set.
  The check for the existence of the file and the creation of the file
  if it does not exist is atomic with respect to other file system
  operations.
 */
inline JavaNioFileStandardOpenOption *JavaNioFileStandardOpenOption_get_CREATE(void);
J2OBJC_ENUM_CONSTANT(JavaNioFileStandardOpenOption, CREATE)

/*!
 @brief Create a new file, failing if the file already exists.
 The check for the existence of the file and the creation of the file
  if it does not exist is atomic with respect to other file system
  operations.
 */
inline JavaNioFileStandardOpenOption *JavaNioFileStandardOpenOption_get_CREATE_NEW(void);
J2OBJC_ENUM_CONSTANT(JavaNioFileStandardOpenOption, CREATE_NEW)

/*!
 @brief Delete on close.When this option is present then the implementation
  makes a <em>best effort</em> attempt to delete the file when closed
  by the appropriate <code>close</code> method.
 If the <code>close</code> method is
  not invoked then a <em>best effort</em> attempt is made to delete the
  file when the Java virtual machine terminates (either normally, as
  defined by the Java Language Specification, or where possible, abnormally).
  This option is primarily intended for use with <em>work files</em> that
  are used solely by a single instance of the Java virtual machine. This
  option is not recommended for use when opening files that are open
  concurrently by other entities. Many of the details as to when and how
  the file is deleted are implementation specific and therefore not
  specified. In particular, an implementation may be unable to guarantee
  that it deletes the expected file when replaced by an attacker while the
  file is open. Consequently, security sensitive applications should take
  care when using this option. 
 <p> For security reasons, this option may imply the <code>LinkOption.NOFOLLOW_LINKS</code>
  option. In other words, if the option is present
  when opening an existing file that is a symbolic link then it may fail
  (by throwing <code>java.io.IOException</code>).
 */
inline JavaNioFileStandardOpenOption *JavaNioFileStandardOpenOption_get_DELETE_ON_CLOSE(void);
J2OBJC_ENUM_CONSTANT(JavaNioFileStandardOpenOption, DELETE_ON_CLOSE)

/*!
 @brief Sparse file.When used with the <code>CREATE_NEW</code> option then this
  option provides a <em>hint</em> that the new file will be sparse.
 The
  option is ignored when the file system does not support the creation of
  sparse files.
 */
inline JavaNioFileStandardOpenOption *JavaNioFileStandardOpenOption_get_SPARSE(void);
J2OBJC_ENUM_CONSTANT(JavaNioFileStandardOpenOption, SPARSE)

/*!
 @brief Requires that every update to the file's content or metadata be written
  synchronously to the underlying storage device.
 - seealso: <a href="package-summary.html#integrity">Synchronized I/O file integrity</a>
 */
inline JavaNioFileStandardOpenOption *JavaNioFileStandardOpenOption_get_SYNC(void);
J2OBJC_ENUM_CONSTANT(JavaNioFileStandardOpenOption, SYNC)

/*!
 @brief Requires that every update to the file's content be written
  synchronously to the underlying storage device.
 - seealso: <a href="package-summary.html#integrity">Synchronized I/O file integrity</a>
 */
inline JavaNioFileStandardOpenOption *JavaNioFileStandardOpenOption_get_DSYNC(void);
J2OBJC_ENUM_CONSTANT(JavaNioFileStandardOpenOption, DSYNC)

FOUNDATION_EXPORT IOSObjectArray *JavaNioFileStandardOpenOption_values(void);

FOUNDATION_EXPORT JavaNioFileStandardOpenOption *JavaNioFileStandardOpenOption_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT JavaNioFileStandardOpenOption *JavaNioFileStandardOpenOption_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(JavaNioFileStandardOpenOption)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaNioFileStandardOpenOption")
